import{_ as e,o as t,c as p,Q as a}from"./chunks/framework.a7175731.js";const _=JSON.parse('{"title":"3Dtiles --笔记","description":"","frontmatter":{},"headers":[],"relativePath":"GIS/Cesium/3DTiles规范解读.md","filePath":"GIS/Cesium/3DTiles规范解读.md","lastUpdated":null}'),s={name:"GIS/Cesium/3DTiles规范解读.md"},i=a('<h1 id="_3dtiles-笔记" tabindex="-1">3Dtiles --笔记 <a class="header-anchor" href="#_3dtiles-笔记" aria-label="Permalink to &quot;3Dtiles --笔记&quot;">​</a></h1><blockquote><p>OGC（Open Geospatial Consortium）开放地理信息联盟 指定的标准格式。相关官方链接及参考文章如下</p><p><a href="https://blog.csdn.net/hhw_hhw/article/details/135103914" target="_blank" rel="noreferrer">https://blog.csdn.net/hhw_hhw/article/details/135103914</a></p><p><a href="https://docs.ogc.org/cs/22-025r4/22-025r4.html#toc0" target="_blank" rel="noreferrer">https://docs.ogc.org/cs/22-025r4/22-025r4.html#toc0</a></p><p><a href="https://www.ogc.org/standards/" target="_blank" rel="noreferrer">https://www.ogc.org/standards/</a></p></blockquote><h3 id="_1-1-起源" tabindex="-1">1.1. 起源 <a class="header-anchor" href="#_1-1-起源" aria-label="Permalink to &quot;1.1. 起源&quot;">​</a></h3><p>3D Tiles 是一种用于流式传输大型三维地理空间数据集的开放规范，主要由 Cesium 创造。这种数据格式的创建背后有几个关键原因：</p><ul><li>高效的数据管理和流式传输：传统的3D数据格式并不适合大规模地理空间数据集的高效流式传输和渲染。3D Tiles 旨在解决这个问题，通过分层级和按需加载的方式，使得大型数据集可以在各种设备上高效地渲染和导航，无论数据集有多大。</li><li>多样化的数据类型支持：3D Tiles 支持多种不同的数据类型，包括点云、3D建模、影像等，这使其成为一种多功能的数据格式，适用于各种不同的地理空间数据应用场景。</li><li>与现有技术的兼容性：3D Tiles 旨在与现有的Web技术和标准（如 WebGL）兼容，这样可以使得基于Web的地理空间应用更容易实现，并可以利用现有的技术生态系统。</li></ul><h3 id="_1-2-后缀类型及特点" tabindex="-1">1.2 后缀类型及特点 <a class="header-anchor" href="#_1-2-后缀类型及特点" aria-label="Permalink to &quot;1.2 后缀类型及特点&quot;">​</a></h3><p>.b3dm：Batched 3D Model，用于存储多个3D模型，这些模型被组织成批次以优化渲染。</p><p>.i3dm：Instanced 3D Model，用于表示大量重复的模型实例，如建筑或树木，这有助于提高渲染效率。</p><p>.pnts：用于点云数据，可以存储大量的点，每个点包含位置、颜色和其他属性信息。</p><p>.cmpt：Composite，用于组合多种类型的3D Tiles数据，例如同时包含点云和3D模型的数据集。</p><p>.json：Tileset JSON 文件，用于描述整个数据集的结构和层级，包含对各个数据块（如 b3dm 或 i3dm 文件）的引用。</p><h4 id="_1-2-1-json" tabindex="-1">1.2.1 json <a class="header-anchor" href="#_1-2-1-json" aria-label="Permalink to &quot;1.2.1 json&quot;">​</a></h4><p>在 3D Tiles 数据格式中，.json 文件通常作为 Tileset JSON 文件，起着至关重要的角色。Tileset JSON 文件描述了整个 3D Tiles 数据集的结构、层级和属性。其主要特点包括：</p><p>数据集结构描述：Tileset JSON 文件定义了整个 3D Tiles 数据集的层级结构。它包含对每个单独瓦片（如.b3dm、.i3dm、.pnts、.cmpt 等）的引用，以及这些瓦片是如何相互关联的信息。</p><p>多级细节（LOD）信息：这种文件包含有关数据集中不同级别细节的信息。这意味着它描述了在不同的视图距离下应当加载哪些瓦片，以优化性能和视觉效果。</p><p>空间分割和索引：Tileset JSON 文件通常包含空间分割信息，如边界盒（bounding boxes）或体积（volumes），这些信息用于快速确定在给定视图或查询中需要渲染或处理哪些瓦片。</p><p>元数据和属性：除了结构信息，Tileset JSON 文件还可以包含关于数据集的元数据和属性，如版权信息、瓦片创建日期、地理位置信息等。</p><p>灵活性和扩展性：由于基于 JSON（JavaScript Object Notation）格式，Tileset JSON 文件易于读写，同时也易于扩展，可以适应各种不同的应用需求。</p><p>与 Web 技术的兼容性：JSON 是 Web 开发中广泛使用的一种数据格式，这使得 Tileset JSON 文件可以轻松地与基于 Web 的地理信息系统（GIS）、虚拟现实（VR）应用和其他三维数据可视化工具集成。</p><p>总的来说，Tileset JSON 文件在 3D Tiles 数据集中扮演着导航图的角色，指导着如何高效地加载和渲染复杂的三维数据。通过使用 Tileset JSON，可以实现对大规模和复杂的三维数据集的高效管理和可视化。</p><h4 id="_1-2-2-b3dm" tabindex="-1">1.2.2 b3dm <a class="header-anchor" href="#_1-2-2-b3dm" aria-label="Permalink to &quot;1.2.2 b3dm&quot;">​</a></h4><p>.b3dm 是 3D Tiles 数据格式中的一种特定文件类型，全称为 “Batched 3D Model”。这种文件格式主要用于高效地存储和传输多个三维模型。其特点包括：</p><p>批处理优化：.b3dm 文件将多个3D模型组合成一个“批次”，使得这些模型可以作为一个整体进行处理和渲染。这种批处理方法大大提高了渲染效率，尤其是在处理包含大量小模型的场景时，例如城市建筑群。</p><p>空间索引和多级细节：与 3D Tiles 的其他组件一样，.b3dm 文件通常与空间索引和多级细节（LOD）技术结合使用。这意味着模型的细节级别会根据观察者的位置和视角动态调整，以优化性能和视觉效果。</p><p>自定义属性支持：.b3dm 文件可以包含与每个模型相关的自定义属性，例如颜色、纹理和元数据。这些属性可用于更加个性化和详细地渲染每个模型。</p><p>与 WebGL 和其他Web技术的兼容性：由于 3D Tiles 和.b3dm 文件格式是为Web环境设计的，它们与 WebGL 等Web图形技术高度兼容，使得在浏览器中渲染这些模型变得容易和高效。</p><p>压缩和优化：.b3dm 文件通常进行压缩处理，以减少文件大小，加快网络传输速度。这对于大型在线地理空间数据应用尤为重要。</p><p>综上所述，.b3dm 文件在 3D Tiles 规范中扮演着重要角色，特别是在处理大量3D建筑模型和其他复杂三维结构时，其优化的批处理和渲染机制显得尤为关键。</p><h4 id="_1-2-3-i3dm" tabindex="-1">1.2.3 i3dm <a class="header-anchor" href="#_1-2-3-i3dm" aria-label="Permalink to &quot;1.2.3 i3dm&quot;">​</a></h4><p>.i3dm 是 3D Tiles 数据格式中的另一种特定文件类型，全称为 “Instanced 3D Model”。这种文件格式专门用于高效地存储和渲染大量重复的三维模型实例。其主要特点包括：</p><p>实例化渲染：.i3dm 文件允许将单个模型的多个实例以高效的方式存储和渲染。这意味着相同的模型可以在不同的位置和方向多次出现，而无需为每个复制存储完整的模型数据。</p><p>空间和渲染优化：使用实例化方法可以大大减少存储和内存占用，同时提高渲染性能。这在处理大量重复对象（如树木、灯柱、车辆等）的场景中特别有效。</p><p>多样性和可配置性：尽管实例是基于同一个模型，但.i3dm 允许对每个实例进行一些变化，例如位置、方向、比例甚至颜色和纹理。这提供了一定程度的可视化多样性。</p><p>与 3D Tiles 其他组件的集成：与 3D Tiles 的其他组件一样，.i3dm 文件通常结合使用空间索引和多级细节（LOD）技术，以优化性能和视觉效果。</p><p>Web技术兼容性：类似于.b3dm，.i3dm 文件也是为与 WebGL 和其他 Web 图形技术高度兼容而设计的，这使得它们非常适合于Web环境中的三维数据应用。</p><p>综上所述，.i3dm 文件格式在处理需要大量重复元素的三维场景时非常有用，如城市规划、虚拟现实和游戏环境等。通过实例化技术，.i3dm 能够以更少的资源占用实现复杂场景的高效渲染。</p><h4 id="_1-2-4-pnts" tabindex="-1">1.2.4 pnts <a class="header-anchor" href="#_1-2-4-pnts" aria-label="Permalink to &quot;1.2.4 pnts&quot;">​</a></h4><p>.pnts 是 3D Tiles 数据格式中专门用于点云数据的文件类型。点云数据是由大量的小点组成的数据集，通常用于表示真实世界的三维形状和特征。.pnts 文件的主要特点包括：</p><p>高密度点云存储：.pnts 文件格式设计用于高效地存储和处理大量的点云数据。每个点可以包含多种信息，如位置、颜色、强度和其他属性。</p><p>适用于大规模空间数据：这种格式特别适合于处理大规模的三维空间数据，例如从激光扫描（LIDAR）或摄影测量技术中获得的数据。</p><p>支持多种属性：除了基本的位置信息，.pnts 文件还可以包含点的其他属性，如RGB颜色、透明度、法线向量、温度、反射率等，这些属性对于更准确和详细地表示点云数据非常重要。</p><p>级别细节和视图依赖渲染：类似于 3D Tiles 的其他组件，.pnts 文件支持多级细节（LOD），允许根据视图距离和角度动态调整点的细节和密度，优化渲染性能和用户体验。</p><p>Web和现代图形技术的兼容性：作为 3D Tiles 规范的一部分，.pnts 文件格式与现代Web图形技术（如 WebGL）兼容，使得在浏览器和其他基于Web的平台上渲染点云数据变得高效和易于实现。</p><p>.pnts 文件因其对大量点云数据的高效处理而被广泛用于各种应用，包括地理信息系统（GIS）、城市规划、虚拟现实、历史遗迹保护等领域。通过使用.pnts格式，开发者可以创建详细且交互性强的三维场景，提供丰富的用户体验。</p><h4 id="_1-2-5-cmpt" tabindex="-1">1.2.5 cmpt <a class="header-anchor" href="#_1-2-5-cmpt" aria-label="Permalink to &quot;1.2.5 cmpt&quot;">​</a></h4><p>.cmpt（Composite Tile）是 3D Tiles 数据格式中的一种文件类型，用于将多种不同类型的 3D Tiles 数据合并成一个单一的文件。这种文件格式的主要特点包括：</p><p>数据多样性：.cmpt 文件可以包含不同类型的 3D Tiles 数据，例如点云（.pnts）、批处理的3D模型（.b3dm）、实例化的3D模型（.i3dm）等。这种多样性使得.cmpt文件能够同时表示多种不同的地理空间数据。</p><p>高效的数据管理：通过将多种数据类型合并到一个文件中，.cmpt 文件可以简化数据管理和传输。这对于需要同时处理多种数据类型的应用场景（如复杂的城市模型）特别有用。</p><p>灵活的场景构建：使用.cmpt文件，开发者可以更灵活地构建复杂场景，因为它允许在一个单一文件中结合不同类型的地理空间元素。</p><p>优化的网络传输：合并多种数据类型到一个文件中可以减少网络请求的数量，从而提高加载速度和性能，特别是在网络条件受限的环境中。</p><p>与 3D Tiles 生态系统的兼容性：.cmpt 文件完全兼容 3D Tiles 规范和生态系统，包括与空间索引、多级细节（LOD）等技术的集成，以优化数据的可视化和性能。</p><p>总的来说，.cmpt 文件在 3D Tiles 数据格式中扮演着集成和优化角色，尤其适用于那些需要同时处理多种不同地理空间数据类型的应用。通过这种方式，开发者可以更有效地管理和渲染复杂的三维场景。</p>',52),l=[i];function o(r,d,n,m,c,h){return t(),p("div",null,l)}const D=e(s,[["render",o]]);export{_ as __pageData,D as default};
