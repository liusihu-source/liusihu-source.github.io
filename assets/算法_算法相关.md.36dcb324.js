import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.a7175731.js";const F=JSON.parse('{"title":"算法相关 --笔记","description":"","frontmatter":{},"headers":[],"relativePath":"算法/算法相关.md","filePath":"算法/算法相关.md","lastUpdated":null}'),p={name:"算法/算法相关.md"},e=l(`<h1 id="算法相关-笔记" tabindex="-1">算法相关 --笔记 <a class="header-anchor" href="#算法相关-笔记" aria-label="Permalink to &quot;算法相关 --笔记&quot;">​</a></h1><h3 id="_1、多视点图" tabindex="-1">1、多视点图 <a class="header-anchor" href="#_1、多视点图" aria-label="Permalink to &quot;1、多视点图&quot;">​</a></h3><p>一个多视点图是一个四元组（Ｖ，Ｗ，Ｅ，Ａ），其中 Ｖ是点集，Ｗ 是点的权集，Ｅ是无向边集，代表两条微博之间的相似度，Ａ是有向边集，代表两条微博在时间上的连续性。</p><h3 id="_2、近似算法求解-approximation-algorithms" tabindex="-1">2、近似算法求解（Approximation algorithms） <a class="header-anchor" href="#_2、近似算法求解-approximation-algorithms" aria-label="Permalink to &quot;2、近似算法求解（Approximation algorithms）&quot;">​</a></h3><p>近似算法不追求找到问题的最优解，而是寻找一个接近最优解的可行解，尽可能在合理的时间内给出一个“接近最优”的解决方案。</p><h3 id="_3、np非确定性多项式时间-nondeterministic-polynomial-time" tabindex="-1">3、NP非确定性多项式时间（Nondeterministic Polynomial time） <a class="header-anchor" href="#_3、np非确定性多项式时间-nondeterministic-polynomial-time" aria-label="Permalink to &quot;3、NP非确定性多项式时间（Nondeterministic Polynomial time）&quot;">​</a></h3><p>多项式时间是指在计算机科学中一种算法的运行时间复杂度描述。<code>其解决方案能够在多项式时间内验证，但尚未找到能在多项式时间内求解的算法。也就是说，如果一个问题的解可以在多项式时间内验证，但目前尚未发现能在多项式时间内找到最优解的算法，这样的问题就被认为是NP难题</code>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">例如，假设有集合U = {1, 2, 3, 4, 5}，以及子集合族S = {{1, 2}, {2, 3}, {3, 4}, {4, 5}}。那么，Set Cover Problem就是要找出最小的子集合组合，使得它们的并集覆盖整个集合U。具体计算公式如下：</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">U = {1, 2, 3, 4, 5}</span></span>
<span class="line"><span style="color:#e1e4e8;">S = {{1, 2}, {2, 3}, {3, 4}, {4, 5}}</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">需要找到最小的子集S&#39;，使得∪(S&#39;) = U。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">对于这个问题，如果使用穷举搜索来找到最优解，它的时间复杂度会非常高，因此通常采用近似算法来求解。一个简单的近似算法是贪心算法，它可以找到一个近似的解。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">贪心算法可以按照以下步骤求解集合覆盖问题：</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">初始化一个空的集合C来表示覆盖的子集。</span></span>
<span class="line"><span style="color:#e1e4e8;">选择一个能够覆盖未覆盖元素最多的子集加入C。</span></span>
<span class="line"><span style="color:#e1e4e8;">重复步骤2，直到所有元素都被覆盖。</span></span>
<span class="line"><span style="color:#e1e4e8;">对于上述问题，可以采用贪心算法，选择子集{1, 2}和{3, 4}，即S&#39; = {{1, 2}, {3, 4}}，它们的并集是{1, 2, 3, 4}，覆盖了整个集合U。虽然这个解不一定是最优解，但是可以作为近似算法的解决方案。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">例如，假设有集合U = {1, 2, 3, 4, 5}，以及子集合族S = {{1, 2}, {2, 3}, {3, 4}, {4, 5}}。那么，Set Cover Problem就是要找出最小的子集合组合，使得它们的并集覆盖整个集合U。具体计算公式如下：</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">U = {1, 2, 3, 4, 5}</span></span>
<span class="line"><span style="color:#24292e;">S = {{1, 2}, {2, 3}, {3, 4}, {4, 5}}</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">需要找到最小的子集S&#39;，使得∪(S&#39;) = U。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">对于这个问题，如果使用穷举搜索来找到最优解，它的时间复杂度会非常高，因此通常采用近似算法来求解。一个简单的近似算法是贪心算法，它可以找到一个近似的解。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">贪心算法可以按照以下步骤求解集合覆盖问题：</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">初始化一个空的集合C来表示覆盖的子集。</span></span>
<span class="line"><span style="color:#24292e;">选择一个能够覆盖未覆盖元素最多的子集加入C。</span></span>
<span class="line"><span style="color:#24292e;">重复步骤2，直到所有元素都被覆盖。</span></span>
<span class="line"><span style="color:#24292e;">对于上述问题，可以采用贪心算法，选择子集{1, 2}和{3, 4}，即S&#39; = {{1, 2}, {3, 4}}，它们的并集是{1, 2, 3, 4}，覆盖了整个集合U。虽然这个解不一定是最优解，但是可以作为近似算法的解决方案。</span></span></code></pre></div><h3 id="_4、最小权重支配集" tabindex="-1">4、最小权重支配集 <a class="header-anchor" href="#_4、最小权重支配集" aria-label="Permalink to &quot;4、最小权重支配集&quot;">​</a></h3><p>图论中的一个概念，用于描述在图中找到一个节点子集，<code>使得这个子集能够覆盖图中的所有节点，并且满足一定条件下的最小化总权重</code>。</p><p>例子</p><p>假设有一个城市网络图，其中包括5个城市，用节点表示（A、B、C、D、E），城市之间的连接用边表示。每个城市节点有一个权重值，表示这个城市的资源消耗。这个图的拓扑如下：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">4</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">---------</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">B</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">\\</span><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">\\</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">1</span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">\\2</span><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">|</span><span style="color:#B392F0;">3</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">\\5</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">     </span><span style="color:#B392F0;">\\</span><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#79B8FF;">\\</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">\\</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">\\</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">C</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">------</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">D</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">------</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">E</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">6</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">4</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">---------</span><span style="color:#24292E;"> </span><span style="color:#032F62;">B</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">  </span><span style="color:#6F42C1;">\\</span><span style="color:#24292E;">       </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">\\</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">1</span><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#6F42C1;">\\2</span><span style="color:#24292E;">     </span><span style="color:#D73A49;">|</span><span style="color:#6F42C1;">3</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">\\5</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">     </span><span style="color:#6F42C1;">\\</span><span style="color:#24292E;">    </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#005CC5;">\\</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">      </span><span style="color:#6F42C1;">\\</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">    </span><span style="color:#005CC5;">\\</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">C</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">------</span><span style="color:#24292E;"> </span><span style="color:#032F62;">D</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">------</span><span style="color:#24292E;"> </span><span style="color:#032F62;">E</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">6</span></span></code></pre></div><p>在这个城市网络中，节点A、B、C、D、E分别代表不同的城市，边上的数字表示这些边的权重。</p><p>城市的权重值如下：</p><ul><li>A: 3</li><li>B: 5</li><li>C: 2</li><li>D: 4</li><li>E: 6</li></ul><p>现在的问题是，选择最小数量的城市，使得这些城市的资源消耗总和最小，并且这些城市要么是支配集中的城市，要么与支配集中的城市相邻。</p><p>针对这个问题，最小权重支配集可能的解决方案是选择城市A和城市E，因为它们能够覆盖所有其他城市，同时这两个城市的权重之和最小（3 + 6 = 9），其他城市要么被选择在支配集中，要么与支配集中的城市相邻。</p><p>这个例子中，最小权重支配集是{A, E}，这两个城市的资源消耗总和为9，而且这两个城市可以覆盖整个城市网络。这个例子展示了如何选择城市节点来形成最小权重支配集，以最小化资源消耗并覆盖整个网络。</p><h3 id="_5、有向斯坦纳树-directed-steiner-tree" tabindex="-1">5、有向斯坦纳树（Directed Steiner Tree） <a class="header-anchor" href="#_5、有向斯坦纳树-directed-steiner-tree" aria-label="Permalink to &quot;5、有向斯坦纳树（Directed Steiner Tree）&quot;">​</a></h3><p>图论中的一个概念，描述了在一个有向图中连接特定顶点集合的最小子图。<code>这个子图包含了这些顶点，并且有向边沿着图中的边连接这些顶点。通常，有向斯坦纳树的目标是连接指定顶点，使得从这些顶点出发到达其他所有指定顶点的总权重或长度最小</code>。</p><h3 id="_6、dijkstra" tabindex="-1">6、Dijkstra <a class="header-anchor" href="#_6、dijkstra" aria-label="Permalink to &quot;6、Dijkstra&quot;">​</a></h3><p>coming...</p>`,23),o=[e];function t(c,r,i,y,E,d){return a(),n("div",null,o)}const C=s(p,[["render",t]]);export{F as __pageData,C as default};
