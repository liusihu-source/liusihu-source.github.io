import{_ as s,c as r,a2 as i,o as t}from"./chunks/framework.BQmytedh.js";const e="/assets/20200728191447349-20230310124032001.D8M0PORt.png",p="/assets/image-20241107135025423.Bm_Jo5_c.png",g=JSON.parse('{"title":"算法整理 --笔记","description":"","frontmatter":{},"headers":[],"relativePath":"计算机/数据结构与算法/常用算法/202411拓展阅读.md","filePath":"计算机/数据结构与算法/常用算法/202411拓展阅读.md","lastUpdated":1767706259000}'),h={name:"计算机/数据结构与算法/常用算法/202411拓展阅读.md"};function n(l,a,E,o,k,c){return t(),r("div",null,a[0]||(a[0]=[i('<h1 id="算法整理-笔记" tabindex="-1">算法整理 --笔记 <a class="header-anchor" href="#算法整理-笔记" aria-label="Permalink to &quot;算法整理 --笔记&quot;">​</a></h1><p>本质：特定计算机模型，用于解决特定问题</p><h2 id="一、时间复杂度" tabindex="-1">一、时间复杂度 <a class="header-anchor" href="#一、时间复杂度" aria-label="Permalink to &quot;一、时间复杂度&quot;">​</a></h2><h3 id="_1-1-概念" tabindex="-1">1.1 概念 <a class="header-anchor" href="#_1-1-概念" aria-label="Permalink to &quot;1.1 概念&quot;">​</a></h3><p>时间复杂度是一个函数，它定性描述该算法的运行时间，记作O(f(n))</p><p>💡 O<strong>是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量</strong></p><p>通常用来表示上界，即对任意数据输入的运行时间的上界</p><p>💡 数据量足够大情况下，时间复杂度排行：O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p><h3 id="_1-2-logn底数" tabindex="-1">1.2 logn底数 <a class="header-anchor" href="#_1-2-logn底数" aria-label="Permalink to &quot;1.2 logn底数&quot;">​</a></h3><p><img src="'+e+`" alt="时间复杂度1.png"></p><p>假如有两个算法的时间复杂度，分别是log以2为底n的对数和log以10为底n的对数。那根据高中数学，<code>以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数</code></p><h2 id="二、空间复杂度" tabindex="-1">二、空间复杂度 <a class="header-anchor" href="#二、空间复杂度" aria-label="Permalink to &quot;二、空间复杂度&quot;">​</a></h2><h3 id="_2-1-概念" tabindex="-1">2.1 概念 <a class="header-anchor" href="#_2-1-概念" aria-label="Permalink to &quot;2.1 概念&quot;">​</a></h3><p>对一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n)</p><h3 id="_2-2-案例" tabindex="-1">2.2 案例 <a class="header-anchor" href="#_2-2-案例" aria-label="Permalink to &quot;2.2 案例&quot;">​</a></h3><div class="language-c++ vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>💡 这段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> create2DArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> row</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每行有 n 个元素，初始值为 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(row);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my2DArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> create2DArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(my2DArray);</span></span></code></pre></div><p>如上代码，空间复杂度为O(n^2) 时间复杂度为O(n)</p><h2 id="三、核心代码模式-和-acm模式" tabindex="-1">三、核心代码模式 和 ACM模式 <a class="header-anchor" href="#三、核心代码模式-和-acm模式" aria-label="Permalink to &quot;三、核心代码模式 和 ACM模式&quot;">​</a></h2><h3 id="_3-1-核心代码" tabindex="-1">3.1 核心代码 <a class="header-anchor" href="#_3-1-核心代码" aria-label="Permalink to &quot;3.1 核心代码&quot;">​</a></h3><p>给出函数名称，参数等，自行实现函数体</p><p><img src="`+p+'" alt="image-20241107135025423"></p><h3 id="_3-2-acm" tabindex="-1">3.2 ACM <a class="header-anchor" href="#_3-2-acm" aria-label="Permalink to &quot;3.2 ACM&quot;">​</a></h3><p>全部空，函数名称、参数、环境等全部没有</p><p>ACM练习链接：<a href="https://kamacoder.com/" target="_blank" rel="noreferrer">https://kamacoder.com/</a></p><h2 id="四、互联网大厂研发流程" tabindex="-1">四、互联网大厂研发流程 <a class="header-anchor" href="#四、互联网大厂研发流程" aria-label="Permalink to &quot;四、互联网大厂研发流程&quot;">​</a></h2><blockquote><p><a href="https://www.bilibili.com/video/BV1KR4y1H7ST/?vd_source=c3aed98126d5ffa7b2c72cf011d9383c" target="_blank" rel="noreferrer">https://www.bilibili.com/video/BV1KR4y1H7ST/?vd_source=c3aed98126d5ffa7b2c72cf011d9383c</a></p></blockquote><h3 id="_1-需求文档" tabindex="-1">1.需求文档 <a class="header-anchor" href="#_1-需求文档" aria-label="Permalink to &quot;1.需求文档&quot;">​</a></h3><p>看需求文档，我们要根据需求文档来确定我们究竟要做什么。</p><p>一些同学可能感觉 为什么还要用一个需求文档呢，你就告诉我做啥我就做啥不就完事了？</p><p>需求文档一方面是<strong>倒逼产品经理去系统性的思考这个需求究竟有哪些功能</strong>，用来满足哪些用户的需求。</p><p>另一方面是<strong>保证我们在研发的时候，研发出来的功能是满足需求文档里所描述的</strong>。</p><p>如果是口头对接的话，很有可能就是你做出来的东西，产品经理看完感觉：这和我说的需求不一样啊！！这和我想的不一样啊！！</p><p>这样就是两个人相互“甩锅”，那这究竟是谁的锅呢。都没有一个证据，对吧。</p><p>所以说，有一个需求文档很重要。</p><p>而且每个阶段的需求文档相当于是把这个项目的整个迭代过程都记录下来了。</p><p>这样也方便后面的人，了解这个项目是如何迭代的。</p><h3 id="_2-这个需求包含了哪些功能" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_2-%E8%BF%99%E4%B8%AA%E9%9C%80%E6%B1%82%E5%8C%85%E5%90%AB%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD" target="_blank" rel="noreferrer">#</a>2.这个需求包含了哪些功能 <a class="header-anchor" href="#_2-这个需求包含了哪些功能" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_2-这个需求包含了哪些功能)2.这个需求包含了哪些功能&quot;">​</a></h3><p>产品经理在需求文档里描述一个功能，那么我们在实现的时候，可能要改很多模块，或者说我们要增加一些模块。</p><p>就是我们从代码的角度上来讲，可能要增添很多功能才能满足 用户看起来好像微不足道的小功能。</p><p>例如点击登录，点击下单，后台都有很多模块协同运行的。</p><p>我们要把产品经理角度上的这个功能，拆解为我们代码角度上的具体应该开发的那些功能。</p><h3 id="_3-确定有哪些难点" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_3-%E7%A1%AE%E5%AE%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9A%BE%E7%82%B9" target="_blank" rel="noreferrer">#</a>3.确定有哪些难点 <a class="header-anchor" href="#_3-确定有哪些难点" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_3-确定有哪些难点)3.确定有哪些难点&quot;">​</a></h3><p>这里可能有同学疑惑了，我确定这东西干嘛呢。</p><p>给大家举一个例子，给你一个需求文档。</p><p>你说你一周的时间就能把它开发完，那为什么是一周呢，为什么不是两天，为什么不是两周呢。</p><p>其实 和上面的领导汇报你的工作的时候 <strong>都要把自己的工作进行量化</strong>。</p><p>那么这个功能有哪些难点，我们要克服这个难点，所需要花费的时间，都要有一个大体的量化。</p><p>这样才能量化我们自己的工作，<strong>领导其实不知道你的工作是简单 还是困难, 领导只在意最终结果</strong>，所以你需要展现给领导你的工作是有难度的是有挑战的。</p><p>而且<strong>这些也是我们年底用来晋升或者评职称的素材</strong>。</p><p>如果这些东西你自己都不在乎的话，谁还会帮你在乎呢。</p><p>而且<strong>确定了自己的工作难点，把这些难点都记录下来，对以后跳槽也很有帮助</strong>。</p><p>面试官最喜欢问的问题，就是：<strong>你做的项目中有哪些难点？以及你是如何克服的</strong>。</p><p>所以这一步对自己个人成长来说也是很有重要的。 对于项目组来说也是记录下来，每一个迭代版本有哪些难点，这些难点团队是如何克服的。</p><p>这也是项目组往上一级去邀功的资料。</p><h3 id="_4-画架构图" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_4-%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE" target="_blank" rel="noreferrer">#</a>4.画架构图 <a class="header-anchor" href="#_4-画架构图" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_4-画架构图)4.画架构图&quot;">​</a></h3><p>一般来说，大厂项目的架构都是比较复杂的，特别是后端架构。</p><p>如果添加一个模块连个文档都没有，连个图也没有，上来就添加的话，后面的人是很难维护的。</p><p>而且每个模块和每一个模块之间的依赖关系，如果没有画出一个架构图的话，直接看代码很容易直接就看懵了。</p><p>为什么你可以快速开发一个新的模块，也是因为之前团队有人把这个架构图画清楚了，你只需要看一眼这个架构图，就知道你的模块应该添加在哪里。</p><p>那么你去添加模块的时候，也应该把这个架构图相应的位置 完善一下。</p><p>同时呢，在画架构图的过程中，也增添了自己对整个系统架构的掌握程度。</p><p>这个图也会让你确定，你的模块在整个项目中扮演一个什么样的角色。</p><h3 id="_5-定协议" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_5-%E5%AE%9A%E5%8D%8F%E8%AE%AE" target="_blank" rel="noreferrer">#</a>5.定协议 <a class="header-anchor" href="#_5-定协议" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_5-定协议)5.定协议&quot;">​</a></h3><p>后台模块之间进行通讯需要协议，后台和前端通讯也需要协议。</p><p>所以只要有交互，就要确定协议的数据格式。</p><p><strong>定协议要考虑到兼容，要考虑易于维护</strong>。</p><h3 id="_6-设计数据结构和算法" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_6-%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95" target="_blank" rel="noreferrer">#</a>6.设计数据结构和算法 <a class="header-anchor" href="#_6-设计数据结构和算法" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_6-设计数据结构和算法)6.设计数据结构和算法&quot;">​</a></h3><p>其实设计数据结构更多一些，因为我们要选择使用什么容器，什么格式来处理我们的数据。</p><p>至于算法的话，就很少我们亲自设计了。</p><p>什么快排，二叉树，动态规划，最短路啥的，在实际开发中，都不需要我们自己去写，<strong>直接调包！</strong></p><p>面试造火箭，工作拧螺丝 就体现在这里。</p><p>为什么会这样呢？ 一个很简单的例子，互联网研发讲究其实就是要快，例如一个功能2天就要开发完，如果算法都要自己去写的话，等都写完了，花都谢了。</p><p>最关键的是，<strong>你实现的算法 极大概率没有现成的算法接口安全性高</strong>。</p><p><strong>开发中要学会才在巨人的肩膀上</strong>。</p><h3 id="_7-预估一下容量" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_7-%E9%A2%84%E4%BC%B0%E4%B8%80%E4%B8%8B%E5%AE%B9%E9%87%8F" target="_blank" rel="noreferrer">#</a>7.预估一下容量 <a class="header-anchor" href="#_7-预估一下容量" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_7-预估一下容量)7.预估一下容量&quot;">​</a></h3><p>特别是后端开发，要估计出 我们自己模块大体需要多大磁盘，多大内存，多大带宽，多少核CPU。</p><p>这也是没有做过研发工作的同学经常忽略的，<strong>因为大家好像默认 磁盘、内存、带宽、cpu是无穷的</strong>。</p><p>其实我们在设计一个模块的时候，这些都要评估的，不能模块一上线，把机器直接打爆了。</p><p>例如 直接把带宽打满了，不仅影响自己的模块功能，还影响了机器上其他模块的运行。</p><h3 id="_8-考虑部署" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_8-%E8%80%83%E8%99%91%E9%83%A8%E7%BD%B2" target="_blank" rel="noreferrer">#</a>8.考虑部署 <a class="header-anchor" href="#_8-考虑部署" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_8-考虑部署)8.考虑部署&quot;">​</a></h3><p>要考虑如果一台机器挂了（可能是硬件原因），那么我们的模块还能不能正常提供服务。</p><p>这就是考虑模块的容灾性，一般都是采用分布式，服务部署在三台机器上，一台如果挂了，还有其他两台提供服务。</p><p>还有就是要弹性可伸缩，即我们的模块可不可以直接 部署多台机器来提高承载能力。</p><p>如果用户量突然上来了，或者流量突然上来了，可以通过快速部署多台机器来抗住流量。</p><p>而不是模块只能在单机上跑，多部署几台就发生各种问题。</p><p><strong>这才能说明是有足够强的风险意识的</strong>。</p><h3 id="_9-设计评审" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_9-%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1" target="_blank" rel="noreferrer">#</a>9.设计评审 <a class="header-anchor" href="#_9-设计评审" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_9-设计评审)9.设计评审&quot;">​</a></h3><p>前八的阶段其实都是设计阶段，那么你的设计需要让组里的同学一起来评审一下，看看有没有什么问题。</p><p>大家主要也是看看你的模块 会不会给其他模块或者整个系统带来什么问题 以及 设计的是否合理。</p><h3 id="_10-写代码" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_10-%E5%86%99%E4%BB%A3%E7%A0%81" target="_blank" rel="noreferrer">#</a>10.写代码 <a class="header-anchor" href="#_10-写代码" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_10-写代码)10.写代码&quot;">​</a></h3><p>终于到写代码的阶段了，其实到这时候，是最容易的。</p><p><strong>写代码就是体力活了，不是脑力活了</strong>。</p><h3 id="_11-自测" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_11-%E8%87%AA%E6%B5%8B" target="_blank" rel="noreferrer">#</a>11.自测 <a class="header-anchor" href="#_11-自测" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_11-自测)11.自测&quot;">​</a></h3><p>写完代码，我们需要自测，自己的功能会不会有什么问题。</p><p>这里可能需要自己造一造数据，跑一跑 看看和预想的是不是一样的。</p><h3 id="_12-联调" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_12-%E8%81%94%E8%B0%83" target="_blank" rel="noreferrer">#</a>12.联调 <a class="header-anchor" href="#_12-联调" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_12-联调)12.联调&quot;">​</a></h3><p>自己的模块可能会涉及到其他模块之间的一个交互，或者和前端的一个交互。</p><p>所以需要其他同学配合一起来测试。</p><p>这里就有很多沟通工作了，因为其他同学可能手头有自己的活，那么就要协调一个时间来一起测试。</p><p>这一步也是很费时间的，<strong>其费时关键是要等，要等其他同学有空和你联调或者是别人等你</strong>，而且往往不是联调一次就能解决问题的。</p><p>所以 在评估开发时间的时候 也要考虑到联调的时间。</p><p>这也是大厂研发效率低的地方，但上百人开发的项目，<strong>这种沟通上消耗也是在所难免的</strong>。</p><h3 id="_13-交给测试" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_13-%E4%BA%A4%E7%BB%99%E6%B5%8B%E8%AF%95" target="_blank" rel="noreferrer">#</a>13.交给测试 <a class="header-anchor" href="#_13-交给测试" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_13-交给测试)13.交给测试&quot;">​</a></h3><p>自己的代码，自己测 一般都测不出什么问题，需要交给测试同学来给你测一测。</p><p>这里如果测试同学测出问题，你就要判断确实有问题还是 测试方式不对，如果有问题就要修改，再提给测试，反反复复这么几轮，直到测试同学测试没问题了。</p><p><strong>这个过程也是累心的</strong>。</p><h3 id="_14-code-review" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_14-code-review" target="_blank" rel="noreferrer">#</a>14.code review <a class="header-anchor" href="#_14-code-review" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_14-code-review)14.code review&quot;">​</a></h3><p>代码合入主干之前，需要 项目组的同学一起来评审一下你的代码。</p><p>之前是评审设计，看设计上有没有什么缺失，这次是大家来看看你代码写的怎么样。</p><p>例如合入主干会不会有什么问题，代码兼容性做的好不好，接口设计的好不好，甚至字段，函数，变量名，命名合不合理。</p><p>都要经过大家的评审，如果有问题就还是要改。</p><p>如果没有问题一般 大家会给+2（就是通过的意思），这样就可以合入主干了。</p><h3 id="_15-合入主干" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_15-%E5%90%88%E5%85%A5%E4%B8%BB%E5%B9%B2" target="_blank" rel="noreferrer">#</a>15.合入主干 <a class="header-anchor" href="#_15-合入主干" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_15-合入主干)15.合入主干&quot;">​</a></h3><p>合入主干为什么会单独列出来呢。</p><p>其实合入主干是很重要的，经常是自己的代码没问题，但合入主干之后就有问题了。</p><p>一般就是合入主干的时候有冲突，例如你从主干拉出一个分支，另一个同学从主干拉出一个分支，而且两个分支修改了同一个模块，如果另一个同学提前合入主干，你再合入主干的时候就会有代码冲突。</p><p>在解决代码冲突的时候 就会修改别人的代码，这个过程很容易产生新的bug。</p><p><strong>一般合入主干之后，测试同学还要重新跑一个全量测试，才能放心发布</strong>。</p><p>如果跑全量测试没有问题的话，才会松一口气（懂的人都懂）。</p><h3 id="_16-发布" tabindex="-1"><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B.html#_16-%E5%8F%91%E5%B8%83" target="_blank" rel="noreferrer">#</a>16.发布 <a class="header-anchor" href="#_16-发布" aria-label="Permalink to &quot;[#](https://programmercarl.com/前序/互联网大厂研发流程.html#_16-发布)16.发布&quot;">​</a></h3><p>最后一步就是发布了。</p><p>发布其实就是把主干的代码更新到线上的服务器上。</p><p>一些还没有工作的同学，可能不太理解究竟什么是发布。</p><p>用大白话来讲，就是把 本地的代码或者某台机器的代码，编译成可执行文件，然后更新到 线上的服务器（一个独立的集群，专门处理线上的流量）并运行起来。</p><p>上线是最重要的一步了，也很容易出问题，因为一个大型项目，其上线的过程都非常复杂（要更新上百台机器的集群），而且<strong>要考虑线上新版和旧版本的兼容问题</strong>。</p><p>这也是为什么大厂项目都选择深夜上线，<strong>因为深夜在线用户最少，如果出问题，影响的用户会比较少，可以快速修复</strong>。</p><p>所以大家经常看到 某大厂程序员深夜上线发布版本之类的</p>',129)]))}const m=s(h,[["render",n]]);export{g as __pageData,m as default};
