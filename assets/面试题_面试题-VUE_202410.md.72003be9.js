import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.a7175731.js";const l="/assets/bV17xC.40d90ddc.png",o="/assets/image-20241022143221766.4aacd53c.png",m=JSON.parse('{"title":"Vue面试题 --笔记","description":"","frontmatter":{},"headers":[],"relativePath":"面试题/面试题-VUE/202410.md","filePath":"面试题/面试题-VUE/202410.md","lastUpdated":null}'),p={name:"面试题/面试题-VUE/202410.md"},t=e(`<h1 id="vue面试题-笔记" tabindex="-1">Vue面试题 --笔记 <a class="header-anchor" href="#vue面试题-笔记" aria-label="Permalink to &quot;Vue面试题 --笔记&quot;">​</a></h1><h2 id="_202410" tabindex="-1">202410 <a class="header-anchor" href="#_202410" aria-label="Permalink to &quot;202410&quot;">​</a></h2><h4 id="_1、vue2-3生命周期" tabindex="-1">1、Vue2/3生命周期 <a class="header-anchor" href="#_1、vue2-3生命周期" aria-label="Permalink to &quot;1、Vue2/3生命周期&quot;">​</a></h4><ul><li><strong>挂载前后</strong>：进行DOM操作、数据请求等。</li><li><strong>更新前后</strong>：响应数据变化，执行依赖于DOM的操作。</li><li><strong>卸载前后</strong>：清理资源，如移除事件监听器、取消定时器等。</li></ul><h5 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;Vue2&quot;">​</a></h5><table><thead><tr><th style="text-align:left;">生命周期</th><th style="text-align:left;">描述</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:left;">beforeCreate</td><td style="text-align:left;">组件实例被创建之初</td><td>执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td></tr><tr><td style="text-align:left;">created</td><td style="text-align:left;">组件实例已经完全创建</td><td>组件初始化完毕，各种数据可以使用，常用于异步数据获取</td></tr><tr><td style="text-align:left;">beforeMount</td><td style="text-align:left;">组件挂载之前</td><td>未执行渲染、更新，dom未创建</td></tr><tr><td style="text-align:left;">mounted</td><td style="text-align:left;">组件挂载到实例上去之后</td><td>初始化结束，dom已创建，可用于获取访问数据和dom元素</td></tr><tr><td style="text-align:left;">beforeUpdate</td><td style="text-align:left;">组件数据发生变化，更新之前</td><td>更新前，可用于获取更新前各种状态，此时<code>view</code>层还未更新</td></tr><tr><td style="text-align:left;">updated</td><td style="text-align:left;">组件数据更新之后</td><td>完成<code>view</code>层的更新；若在<code>updated</code>中再次修改数据，会再次触发更新方法（<code>beforeUpdate</code>、<code>updated</code>）</td></tr><tr><td style="text-align:left;">beforeDestroy</td><td style="text-align:left;">组件实例销毁之前</td><td>销毁前，可用于一些定时器或订阅的取消</td></tr><tr><td style="text-align:left;">destroyed</td><td style="text-align:left;">组件实例销毁之后</td><td>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</td></tr></tbody></table><p>💡 created 和 mounted之间的区别</p><ul><li><code>created</code>是在组件实例一旦创建完成的时候立刻调用，这时候页面<code>dom</code>节点并未生成；<code>created</code>是比<code>mounted</code>要更早的</li><li><code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后就立刻执行的。</li></ul><p>💡 created 和 mounted之间的相同点</p><p>都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在<code>mounted</code>中的请求有可能导致页面闪动（因为此时页面<code>dom</code>结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在<code>created</code>生命周期当中。</p><h5 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h5><p><strong>在【options API】中，生命周期钩子是被暴露在vue实例上的选项，我们只需要调用使用即可。</strong></p><p><strong>在【composition API】中，我们需要将生命周期钩子导入项目，然后才能使用。</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> {onMounted} </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;vue&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> {onMounted} </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;vue&#39;</span></span></code></pre></div><ul><li><code>onBeforeMount</code> 是在组件挂载之前调用的生命周期钩子。此时，组件的模板已经渲染为HTML，但是还没有添加到页面中</li><li><code>onMounted</code> 是在组件挂载完成后调用的生命周期钩子。此时，可以执行依赖于DOM的操作，例如获取元素的尺寸或启动动画</li><li><code>onBeforeUpdate</code> 是在组件更新之前调用的生命周期钩子。这发生在响应式数据变化后，组件的虚拟DOM重新渲染之前</li><li><code>onUpdated</code> 是在组件更新完成后调用的生命周期钩子。这发生在响应式数据变化后，组件的虚拟DOM重新渲染并已应用到真实DOM之后</li><li><code>onBeforeUnmount</code> 是在组件卸载之前调用的生命周期钩子。这发生在组件被销毁之前，可以用来执行清理操作，如取消网络请求、移除事件监听器等</li><li><code>onUnmounted</code> 是在组件卸载完成后调用的生命周期钩子。此时，组件已经从页面中移除，可以执行一些最终的清理工作。</li></ul><h4 id="_2、vue-nexttick" tabindex="-1">2、Vue nextTick <a class="header-anchor" href="#_2、vue-nexttick" aria-label="Permalink to &quot;2、Vue nextTick&quot;">​</a></h4><blockquote><p>Vue 实现响应式并<strong>不是数据发生变化之后 DOM 立即变化</strong>，而是按一定的策略进行 DOM 的更新。</p><ul><li><code>Vue</code> 在更新 <code>DOM</code> 时是异步执行的。当数据发生变化，<code>Vue</code>将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</li></ul></blockquote><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//改变数据</span></span>
<span class="line"><span style="color:#E1E4E8;">vm.message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;changed&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(vm.$el.textContent) </span><span style="color:#6A737D;">// 并不会得到&#39;changed&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span>
<span class="line"><span style="color:#E1E4E8;">Vue.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(vm.$el.textContent) </span><span style="color:#6A737D;">//可以得到&#39;changed&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//改变数据</span></span>
<span class="line"><span style="color:#24292E;">vm.message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;changed&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(vm.$el.textContent) </span><span style="color:#6A737D;">// 并不会得到&#39;changed&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span>
<span class="line"><span style="color:#24292E;">Vue.</span><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(vm.$el.textContent) </span><span style="color:#6A737D;">//可以得到&#39;changed&#39;</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre></div><p><img src="`+l+`" alt="clipboard.png"></p><p>使用案例</p><p>点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//错误</span></span>
<span class="line"><span style="color:#B392F0;">showsou</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.showit </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">//修改 v-show</span></span>
<span class="line"><span style="color:#E1E4E8;">  document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;keywords&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">focus</span><span style="color:#E1E4E8;">()  </span><span style="color:#6A737D;">//在第一个 tick 里，获取不到输入框，自然也获取不到焦点</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">//修正</span></span>
<span class="line"><span style="color:#B392F0;">showsou</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.showit </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">$nextTick</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// DOM 更新了</span></span>
<span class="line"><span style="color:#E1E4E8;">    document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;keywords&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">focus</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//错误</span></span>
<span class="line"><span style="color:#6F42C1;">showsou</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.showit </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">//修改 v-show</span></span>
<span class="line"><span style="color:#24292E;">  document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;keywords&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">focus</span><span style="color:#24292E;">()  </span><span style="color:#6A737D;">//在第一个 tick 里，获取不到输入框，自然也获取不到焦点</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">//修正</span></span>
<span class="line"><span style="color:#6F42C1;">showsou</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.showit </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">$nextTick</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// DOM 更新了</span></span>
<span class="line"><span style="color:#24292E;">    document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;keywords&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">focus</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="_3、vue2选项式api-和-vue3组合式api" tabindex="-1">3、Vue2选项式API 和 Vue3组合式API <a class="header-anchor" href="#_3、vue2选项式api-和-vue3组合式api" aria-label="Permalink to &quot;3、Vue2选项式API 和 Vue3组合式API&quot;">​</a></h4><ul><li>在逻辑组织和逻辑复用方面，组合式更倾向将相关联的数据和方法放在一起，而选项式则更加分散，不易于集中管理（高内聚，低耦合）</li><li>Vue3原生支持TypeScript，提高了类型检查和类型判断能力</li><li>Vue3向下兼容Vue2语法，小组件也可继续使用</li><li>Vue2采用defineProperty（）、Vue3使用Proxy对象代理整个数据对象</li></ul><h4 id="_4、vue中的虚拟dom" tabindex="-1">4、Vue中的虚拟DOM <a class="header-anchor" href="#_4、vue中的虚拟dom" aria-label="Permalink to &quot;4、Vue中的虚拟DOM&quot;">​</a></h4><p>概念：虚拟DOM是对真实DOM的抽象表达。在javaScript对象中，虚拟DOM表现为一个Object对象，并且最少包含 标签名、属性和子元素对象三个属性。</p><p>💡 在Vue的源码中，存在VNode类，该类的构造函数中包含tag、children等属性。不过具体如何通过VNode类创建 和 删除节点未曾深入了解。</p><h4 id="_5、vue2-vue3区别" tabindex="-1">5、Vue2&amp;Vue3区别 <a class="header-anchor" href="#_5、vue2-vue3区别" aria-label="Permalink to &quot;5、Vue2&amp;Vue3区别&quot;">​</a></h4><blockquote><ol><li>编码方式</li><li>生命周期</li><li>TypeScript</li><li>响应式原理</li><li>性能优化</li><li>Diff改进</li></ol></blockquote><h5 id="编码方式" tabindex="-1">编码方式 <a class="header-anchor" href="#编码方式" aria-label="Permalink to &quot;编码方式&quot;">​</a></h5><p>Vue2</p><ul><li><p>选项式API，逻辑分散</p></li><li><p>data 和 methods；</p></li></ul><p>Vue3</p><ul><li>组合式API ，setup内部统一声明逻辑，逻辑内聚</li><li>ref reactive watch computed</li></ul><h5 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h5><p><img src="`+o+`" alt="image-20241022143221766"></p><h5 id="typescript支持" tabindex="-1">Typescript支持 <a class="header-anchor" href="#typescript支持" aria-label="Permalink to &quot;Typescript支持&quot;">​</a></h5><p>vue2 源码是javascript编写，需要手动维护类型定义</p><p>vue3是typescript编写，原生支持ts</p><h5 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h5><ul><li>Vue2 使用Object.defineProperty()监听对象的属性访问和修改。对于数组的监听需要特殊处理，Vue2重写了数组的方法，如push pop等</li><li>Vue3使用ES6中的Proxy代理，Proxy可以拦截并重定义对象上的操作；组合式API对数据的处理更加便捷，因为可以把相关的变量常量方法放在一起，</li></ul><h5 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h5><ul><li><p>数据监听机制优化。Vue2的Object.defineProperty()通过数据劫持方式监听，需要遍历所有属性，存在性能开销；Vue3使用Proxy，直接监听对象，减少遍历时间。</p></li><li><p>减小包体积。</p><ul><li><p>vue3引入<code>Tree shaking</code> 是一种通过清除多余代码方式来优化项目打包体积的技术</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul></li><li><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//vue2</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> Vue </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;vue&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">Vue.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//vue3</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { nextTick, observable } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;vue&#39;</span></span>
<span class="line"><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//vue2</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> Vue </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;vue&#39;</span></span>
<span class="line"><span style="color:#24292E;">Vue.</span><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//vue3</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { nextTick, observable } </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;vue&#39;</span></span>
<span class="line"><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {})</span></span></code></pre></div></li></ul></li><li><p>编译优化，如静态节点提升 和 缓存时间处理函数等</p></li></ul><h5 id="diff改进" tabindex="-1">Diff改进 <a class="header-anchor" href="#diff改进" aria-label="Permalink to &quot;Diff改进&quot;">​</a></h5><p>虚拟DOM到真实DOM的新旧VNode节点比较。</p><ul><li>Vue2 使用双指针的Diff算法</li><li>Vue3 更高效的单端比较Diff算法（深度优先，循环从两边向中间靠拢）</li></ul>`,46),c=[t];function r(i,d,y,u,E,h){return a(),n("div",null,c)}const f=s(p,[["render",r]]);export{m as __pageData,f as default};
