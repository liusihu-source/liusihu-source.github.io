import{_ as i,c as a,a2 as t,o as e}from"./chunks/framework.BQmytedh.js";const n="/assets/bV17xC.DNf46WFK.png",l="/assets/image-20241022143221766.CI0pTuwd.png",h="/assets/df14a5a0-3ac6-11eb-85f6-6fac77c0c9b3.Dv03dwbP.png",p="/assets/eeb13aa0-3ac6-11eb-85f6-6fac77c0c9b3.Ck5n6uLb.png",u=JSON.parse('{"title":"Vue面试题 --笔记","description":"","frontmatter":{},"headers":[],"relativePath":"面试题/面试题-VUE/202410.md","filePath":"面试题/面试题-VUE/202410.md","lastUpdated":null}'),k={name:"面试题/面试题-VUE/202410.md"};function d(r,s,E,o,c,g){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="vue面试题-笔记" tabindex="-1">Vue面试题 --笔记 <a class="header-anchor" href="#vue面试题-笔记" aria-label="Permalink to &quot;Vue面试题 --笔记&quot;">​</a></h1><h2 id="_202410" tabindex="-1">202410 <a class="header-anchor" href="#_202410" aria-label="Permalink to &quot;202410&quot;">​</a></h2><h3 id="_1、vue2-3生命周期" tabindex="-1">1、Vue2/3生命周期 <a class="header-anchor" href="#_1、vue2-3生命周期" aria-label="Permalink to &quot;1、Vue2/3生命周期&quot;">​</a></h3><ul><li><strong>挂载前后</strong>：进行DOM操作、数据请求等。</li><li><strong>更新前后</strong>：响应数据变化，执行依赖于DOM的操作。</li><li><strong>卸载前后</strong>：清理资源，如移除事件监听器、取消定时器等。</li></ul><h5 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;Vue2&quot;">​</a></h5><table tabindex="0"><thead><tr><th style="text-align:left;">生命周期</th><th style="text-align:left;">描述</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:left;">beforeCreate</td><td style="text-align:left;">组件实例被创建之初</td><td>执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td></tr><tr><td style="text-align:left;">created</td><td style="text-align:left;">组件实例已经完全创建</td><td>组件初始化完毕，各种数据可以使用，常用于异步数据获取</td></tr><tr><td style="text-align:left;">beforeMount</td><td style="text-align:left;">组件挂载之前</td><td>未执行渲染、更新，dom未创建</td></tr><tr><td style="text-align:left;">mounted</td><td style="text-align:left;">组件挂载到实例上去之后</td><td>初始化结束，dom已创建，可用于获取访问数据和dom元素</td></tr><tr><td style="text-align:left;">beforeUpdate</td><td style="text-align:left;">组件数据发生变化，更新之前</td><td>更新前，可用于获取更新前各种状态，此时<code>view</code>层还未更新</td></tr><tr><td style="text-align:left;">updated</td><td style="text-align:left;">组件数据更新之后</td><td>完成<code>view</code>层的更新；若在<code>updated</code>中再次修改数据，会再次触发更新方法（<code>beforeUpdate</code>、<code>updated</code>）</td></tr><tr><td style="text-align:left;">beforeDestroy</td><td style="text-align:left;">组件实例销毁之前</td><td>销毁前，可用于一些定时器或订阅的取消</td></tr><tr><td style="text-align:left;">destroyed</td><td style="text-align:left;">组件实例销毁之后</td><td>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</td></tr></tbody></table><p>💡 created 和 mounted之间的区别</p><ul><li><code>created</code>是在组件实例一旦创建完成的时候立刻调用，这时候页面<code>dom</code>节点并未生成；<code>created</code>是比<code>mounted</code>要更早的</li><li><code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后就立刻执行的。</li></ul><p>💡 created 和 mounted之间的相同点</p><p>都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在<code>mounted</code>中的请求有可能导致页面闪动（因为此时页面<code>dom</code>结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在<code>created</code>生命周期当中。</p><h5 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h5><p><strong>在【options API】中，生命周期钩子是被暴露在vue实例上的选项，我们只需要调用使用即可。</strong></p><p><strong>在【composition API】中，我们需要将生命周期钩子导入项目，然后才能使用。</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {onMounted} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span></code></pre></div><ul><li><code>onBeforeMount</code> 是在组件挂载之前调用的生命周期钩子。此时，组件的模板已经渲染为HTML，但是还没有添加到页面中</li><li><code>onMounted</code> 是在组件挂载完成后调用的生命周期钩子。此时，可以执行依赖于DOM的操作，例如获取元素的尺寸或启动动画</li><li><code>onBeforeUpdate</code> 是在组件更新之前调用的生命周期钩子。这发生在响应式数据变化后，组件的虚拟DOM重新渲染之前</li><li><code>onUpdated</code> 是在组件更新完成后调用的生命周期钩子。这发生在响应式数据变化后，组件的虚拟DOM重新渲染并已应用到真实DOM之后</li><li><code>onBeforeUnmount</code> 是在组件卸载之前调用的生命周期钩子。这发生在组件被销毁之前，可以用来执行清理操作，如取消网络请求、移除事件监听器等</li><li><code>onUnmounted</code> 是在组件卸载完成后调用的生命周期钩子。此时，组件已经从页面中移除，可以执行一些最终的清理工作。</li></ul><h3 id="_2、vue-nexttick" tabindex="-1">2、Vue nextTick <a class="header-anchor" href="#_2、vue-nexttick" aria-label="Permalink to &quot;2、Vue nextTick&quot;">​</a></h3><blockquote><p>Vue 实现响应式并<strong>不是数据发生变化之后 DOM 立即变化</strong>，而是按一定的策略进行 DOM 的更新。</p><ul><li><code>Vue</code> 在更新 <code>DOM</code> 时是异步执行的。当数据发生变化，<code>Vue</code>将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</li></ul></blockquote><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//改变数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vm.message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;changed&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.$el.textContent) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 并不会得到&#39;changed&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.$el.textContent) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//可以得到&#39;changed&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p><img src="`+n+`" alt="clipboard.png"></p><p>使用案例</p><p>点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//错误</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showsou</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.showit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //修改 v-show</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keywords&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//在第一个 tick 里，获取不到输入框，自然也获取不到焦点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//修正</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showsou</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.showit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // DOM 更新了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keywords&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3、vue2选项式api-和-vue3组合式api" tabindex="-1">3、Vue2选项式API 和 Vue3组合式API <a class="header-anchor" href="#_3、vue2选项式api-和-vue3组合式api" aria-label="Permalink to &quot;3、Vue2选项式API 和 Vue3组合式API&quot;">​</a></h3><ul><li>在逻辑组织和逻辑复用方面，组合式更倾向将相关联的数据和方法放在一起，而选项式则更加分散，不易于集中管理（高内聚，低耦合）</li><li>Vue3原生支持TypeScript，提高了类型检查和类型判断能力</li><li>Vue3向下兼容Vue2语法，小组件也可继续使用</li><li>Vue2采用defineProperty（）、Vue3使用Proxy对象代理整个数据对象</li></ul><h3 id="_4、vue中的虚拟dom" tabindex="-1">4、Vue中的虚拟DOM <a class="header-anchor" href="#_4、vue中的虚拟dom" aria-label="Permalink to &quot;4、Vue中的虚拟DOM&quot;">​</a></h3><p>概念：虚拟DOM是对真实DOM的抽象表达。在javaScript对象中，虚拟DOM表现为一个Object对象，并且最少包含 标签名、属性和子元素对象三个属性。</p><p>💡 在Vue的源码中，存在VNode类，该类的构造函数中包含tag、children等属性。不过具体如何通过VNode类创建 和 删除节点未曾深入了解。</p><h3 id="_5、vue2-vue3区别" tabindex="-1">5、Vue2&amp;Vue3区别 <a class="header-anchor" href="#_5、vue2-vue3区别" aria-label="Permalink to &quot;5、Vue2&amp;Vue3区别&quot;">​</a></h3><blockquote><ol><li>编码方式</li><li>生命周期</li><li>TypeScript</li><li>响应式原理</li><li>性能优化</li><li>Diff改进</li></ol></blockquote><h5 id="编码方式" tabindex="-1">编码方式 <a class="header-anchor" href="#编码方式" aria-label="Permalink to &quot;编码方式&quot;">​</a></h5><p>Vue2</p><ul><li><p>选项式API，逻辑分散</p></li><li><p>data 和 methods；</p></li></ul><p>Vue3</p><ul><li>组合式API ，setup内部统一声明逻辑，逻辑内聚</li><li>ref reactive watch computed</li></ul><h5 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h5><p><img src="`+l+`" alt="image-20241022143221766"></p><h5 id="typescript支持" tabindex="-1">Typescript支持 <a class="header-anchor" href="#typescript支持" aria-label="Permalink to &quot;Typescript支持&quot;">​</a></h5><p>vue2 源码是javascript编写，需要手动维护类型定义</p><p>vue3是typescript编写，原生支持ts</p><h5 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h5><ul><li>Vue2 使用Object.defineProperty()监听对象的属性访问和修改。对于数组的监听需要特殊处理，Vue2重写了数组的方法，如push pop等</li><li>Vue3使用ES6中的Proxy代理，Proxy可以拦截并重定义对象上的操作；组合式API对数据的处理更加便捷，因为可以把相关的变量常量方法放在一起，</li></ul><h5 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h5><ul><li><p>数据监听机制优化。Vue2的Object.defineProperty()通过数据劫持方式监听，需要遍历所有属性，存在性能开销；Vue3使用Proxy，直接监听对象，减少遍历时间。</p></li><li><p>减小包体积。</p><ul><li><p>vue3引入<code>Tree shaking</code> 是一种通过清除多余代码方式来优化项目打包体积的技术</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul></li><li><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//vue2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//vue3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { nextTick, observable } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {})</span></span></code></pre></div></li></ul></li><li><p>编译优化，如静态节点提升 和 缓存时间处理函数等</p></li></ul><h5 id="diff改进" tabindex="-1">Diff改进 <a class="header-anchor" href="#diff改进" aria-label="Permalink to &quot;Diff改进&quot;">​</a></h5><p>虚拟DOM到真实DOM的新旧VNode节点比较。</p><ul><li>Vue2 使用双指针的Diff算法</li><li>Vue3 更高效的单端比较Diff算法（深度优先，循环从两边向中间靠拢）</li></ul><h3 id="_6、哈希路由-历史路由" tabindex="-1">6、哈希路由 &amp; 历史路由 <a class="header-anchor" href="#_6、哈希路由-历史路由" aria-label="Permalink to &quot;6、哈希路由 &amp; 历史路由&quot;">​</a></h3><blockquote><p>vue中两种常见的路由模式</p></blockquote><h5 id="哈希路由" tabindex="-1">哈希路由 <a class="header-anchor" href="#哈希路由" aria-label="Permalink to &quot;哈希路由&quot;">​</a></h5><p>由于浏览器中，#后面的内容会被视作界面的一个锚点，不会发送到服务器。所以router使用#(hash)管理路由，实现单页面应用程序。</p><h5 id="历史路由" tabindex="-1">历史路由 <a class="header-anchor" href="#历史路由" aria-label="Permalink to &quot;历史路由&quot;">​</a></h5><p>URL中不包含 # 符号，采用常规的路径格式。例如：<code>https://example.com/user/profile</code>.</p><p>使用方式</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createRouter, createWebHashHistory } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> routes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redirect: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/login&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@/views/login/Login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/home&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 使用动态导入 (import()) 来懒加载 Login 组件。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@/views/home/Home&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    meta: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      requireAuth: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  history: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createWebHashHistory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to.matched.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">record</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> record.meta.requireAuth)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (localStorage.token) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          query: { redirect: to.fullPath }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> router</span></span></code></pre></div><h3 id="_7、单页面应用-和-多页面应用" tabindex="-1">7、单页面应用 和 多页面应用 <a class="header-anchor" href="#_7、单页面应用-和-多页面应用" aria-label="Permalink to &quot;7、单页面应用 和 多页面应用&quot;">​</a></h3><h5 id="单页面应用" tabindex="-1">单页面应用 <a class="header-anchor" href="#单页面应用" aria-label="Permalink to &quot;单页面应用&quot;">​</a></h5><p>一种网站的模型，通过替换页面标签及资源等实现页面更新，而不进行页面的跳转。</p><p><code>vue、react、angular都是</code></p><p><img src="`+h+'" alt="img"></p><p>案例网站：</p><p><a href="http://123.249.125.209/index10.html#/Home/Product" target="_blank" rel="noreferrer">http://123.249.125.209/index10.html#/Home/Product</a></p><p><a href="https://liusihu-source.github.io/" target="_blank" rel="noreferrer">https://liusihu-source.github.io/</a></p><h5 id="多页面应用" tabindex="-1">多页面应用 <a class="header-anchor" href="#多页面应用" aria-label="Permalink to &quot;多页面应用&quot;">​</a></h5><p>一种网站的模型，每个页面都是独立的主页面，需要重新加载html、css和js</p><p><img src="'+p+'" alt="img"></p><p>两者对比</p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">单页面应用（SPA）</th><th>多页面应用（MPA）</th></tr></thead><tbody><tr><td style="text-align:left;">组成</td><td style="text-align:left;">一个主页面和多个页面片段</td><td>多个主页面</td></tr><tr><td style="text-align:left;">刷新方式</td><td style="text-align:left;">局部刷新</td><td>整页刷新</td></tr><tr><td style="text-align:left;">url模式</td><td style="text-align:left;">哈希模式</td><td>历史模式</td></tr><tr><td style="text-align:left;">SEO搜索引擎优化</td><td style="text-align:left;">难实现，可使用SSR方式改善</td><td>容易实现</td></tr><tr><td style="text-align:left;">数据传递</td><td style="text-align:left;">容易</td><td>通过url、cookie、localStorage等传递</td></tr><tr><td style="text-align:left;">页面切换</td><td style="text-align:left;">速度快，用户体验良好</td><td>切换加载资源，速度慢，用户体验差</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td><td></td></tr></tbody></table>',67)]))}const F=i(k,[["render",d]]);export{u as __pageData,F as default};
